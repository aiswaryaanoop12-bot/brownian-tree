<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brownian Tree (DLA)</title>
  <style>
    :root { --bg:#ffffff; --fg:#111111; --ui-bg: #f7f7f7; }
    html,body { height:100%; margin:0; background:var(--bg); font-family:system-ui,-apple-system,Segoe UI,Roboto; }
    .wrap { display:flex; gap:20px; padding:18px; align-items:flex-start; }
    canvas { background:var(--bg); box-shadow:0 8px 30px rgba(0,0,0,.08); border:1px solid #ddd; }
    .controls { width:300px; background:var(--ui-bg); padding:12px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,.04); }
    .row { margin-bottom:10px; }
    label { display:block; font-size:13px; color:#333; margin-bottom:6px; }
    input[type="range"] { width:100%; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:white; cursor:pointer; }
    small { color:#666; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="700" height="700"></canvas>

    <div class="controls">
      <div class="row"><strong>Brownian Tree (DLA)</strong><div><small>Seed in center: particles random-walk until they touch the aggregate and stick.</small></div></div>

      <div class="row">
        <label>Spawn Radius: <span id="spawnRLabel">300</span></label>
        <input id="spawnR" type="range" min="50" max="600" value="300" />
      </div>

      <div class="row">
        <label>Kill Radius (escape): <span id="killRLabel">680</span></label>
        <input id="killR" type="range" min="100" max="1200" value="680" />
      </div>

      <div class="row">
        <label>Particles per frame: <span id="perFrameLabel">4</span></label>
        <input id="perFrame" type="range" min="1" max="200" value="4" />
      </div>

      <div class="row">
        <label>Particle color:</label>
        <input id="col" type="color" value="#111111" />
      </div>

      <div class="row">
        <button id="reset">Reset</button>
        <button id="pause">Pause</button>
        <button id="screenshot">Download screenshot</button>
      </div>

      <div class="row">
        <small>Tip: increase particles-per-frame for faster growth, or reduce to watch it form slowly.</small>
      </div>
    </div>
  </div>

  <script>
  // Brownian Tree (DLA) - single file
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = Math.floor(W/2), cy = Math.floor(H/2);

  // UI elements
  const spawnR = document.getElementById('spawnR');
  const killR = document.getElementById('killR');
  const perFrame = document.getElementById('perFrame');
  const col = document.getElementById('col');
  const resetBtn = document.getElementById('reset');
  const pauseBtn = document.getElementById('pause');
  const screenshotBtn = document.getElementById('screenshot');
  const spawnRLabel = document.getElementById('spawnRLabel');
  const killRLabel = document.getElementById('killRLabel');
  const perFrameLabel = document.getElementById('perFrameLabel');

  spawnR.oninput = () => spawnRLabel.textContent = spawnR.value;
  killR.oninput = () => killRLabel.textContent = killR.value;
  perFrame.oninput = () => perFrameLabel.textContent = perFrame.value;

  // Pixel grid: 1 if occupied (part of aggregate)
  const grid = new Uint8Array(W*H);

  function idx(x,y){ return y*W + x; }

  // draw seed in center
  function setSeed(){
    grid.fill(0);
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = col.value;
    ctx.fillRect(cx, cy, 1, 1);
    grid[idx(cx,cy)] = 1;
    drawImageData = ctx.getImageData(0,0,W,H);
  }

  // prepare imageData for fast pixel writes
  let drawImageData = ctx.getImageData(0,0,W,H);
  function putPixel(x,y,r,g,b,a=255){
    if (x<0||x>=W||y<0||y>=H) return;
    const p = (y*W + x)*4;
    drawImageData.data[p] = r;
    drawImageData.data[p+1] = g;
    drawImageData.data[p+2] = b;
    drawImageData.data[p+3] = a;
    grid[idx(x,y)] = 1;
  }

  // read whether neighbor is occupied (4-neighbour)
  function neighborsOccupied(x,y){
    if (x>0 && grid[idx(x-1,y)]) return true;
    if (x<W-1 && grid[idx(x+1,y)]) return true;
    if (y>0 && grid[idx(x,y-1)]) return true;
    if (y<H-1 && grid[idx(x,y+1)]) return true;
    return false;
  }

  // spawn particle on circumference at radius R
  function spawnParticle(R){
    const a = Math.random()*Math.PI*2;
    const x = Math.floor(cx + Math.cos(a)*R);
    const y = Math.floor(cy + Math.sin(a)*R);
    return {x,y};
  }

  // simple random walk (4 directions) until it sticks or escapes
  function walkAndStick(spawnRadius, killRadius, colorRGB){
    let {x,y} = spawnParticle(spawnRadius);
    // walk for up to some steps to avoid infinite loops
    const maxSteps = 200000;
    for (let step=0; step<maxSteps; step++){
      // if out of bounds or past kill radius -> kill the walker
      const dx = x - cx, dy = y - cy;
      if (dx*dx + dy*dy > killRadius*killRadius) return false;

      // if adjacent to aggregate, stick here
      if (neighborsOccupied(x,y)){
        putPixel(x,y,colorRGB[0],colorRGB[1],colorRGB[2],255);
        return true;
      }

      // random move 4-neighbour
      const r = Math.floor(Math.random()*4);
      if (r===0) x++;
      else if (r===1) x--;
      else if (r===2) y++;
      else y--;

      // clamp to canvas
      if (x <= 0) x = 1;
      if (x >= W-1) x = W-2;
      if (y <= 0) y = 1;
      if (y >= H-1) y = H-2;
    }
    return false;
  }

  // main loop
  let running = true;
  function frame(){
    if (!running) return;
    const spawnRval = Number(spawnR.value);
    const killRval = Number(killR.value);
    const per = Number(perFrame.value);
    // parse color hex to rgb
    const hex = col.value.replace('#','');
    const colorRGB = [parseInt(hex.substring(0,2),16), parseInt(hex.substring(2,4),16), parseInt(hex.substring(4,6),16)];

    // add N walkers this frame
    for (let i=0;i<per;i++){
      walkAndStick(spawnRval, killRval, colorRGB);
    }

    ctx.putImageData(drawImageData,0,0);
    requestAnimationFrame(frame);
  }

  // controls
  resetBtn.onclick = () => { setSeed(); };
  pauseBtn.onclick = () => {
    running = !running;
    if (running){ pauseBtn.textContent = 'Pause'; requestAnimationFrame(frame); }
    else pauseBtn.textContent = 'Resume';
  };
  screenshotBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = 'brownian-tree.png';
    a.click();
  };

  // initial start
  setSeed();
  requestAnimationFrame(frame);
  </script>
</body>
</html>
